## 概念引入

一般涉及生命周期主要有三种操作：
- 获取资源	
- 使用资源
- 释放资源


| 对象生命周期      | 举例 C++ 标准库                               |
|:------------|:-----------------------------------------|
| 对象创建时，获取资源  | 构造 fstream 时根据 filename/open_mode 打开对应文件 |
| 通过访问对象，使用资源 | 调用 fstream 的 read/write 函数读写文件           |
| 对象销毁时，释放资源  | 析构 fstream 关闭对应文件                        |

#### 资源对象的访问

在面向对象语言中，对资源的操作就被封装到了对象里 —— 对象成员方法的访问，会被 映射 为资源的使用。例如，调用 file_object.read 会映射为读取文件的操作，file_object.write 会映射为写入文件的操作。

在面向对象程序中，访问资源对象的接口 和 使用资源的实际操作，不一定直接相关。例如，C++ 标准库中 std::basic_fstream 提供的读取数据接口 std::basic_istream::read 并不属于 fstream，而属于其基类 istream。

而在调用 istream.read 时，使用者并不关心具体使用的是哪种来源读取数据 —— 支持 read 操作的来源可能是 标准输入输出流（iostream）/ 字符串流（stringstream）/ 文件流（fstream）。只有传入的 istream 是 fstream 时，才会访问文件资源。

在面向对象语言中，由于 多态 (Polymorphism) 概念的引入，把资源对象的 访问操作 和 创建/销毁 分离 —— 可以通过资源对象的基类接口，隐式地把 基类接口的访问 映射到 资源的使用 上。

#### 资源对象的销毁
程序设计语言中，对象的销毁主要有两种方式：

- 手动销毁 —— 需要在 代码显式 销毁对象
- 自动销毁 —— 一般通过 运行时系统 提供的 垃圾回收 机制完成，不由程序主动销毁
对于资源对象的销毁，这两种方式在不同应用场景下各有利弊。例如：

手动销毁

不释放不再使用 的资源，会导致 泄露 问题（可以使用 RAII 机制避免）
使用被释放 的资源，会导致 悬垂引用 问题（可以使用弱引用机制避免）
释放正在使用 的资源，会导致 崩溃 问题
单线程常见于：在对象回调栈上删除对象本身（例如 UI 弹出上下文菜单，点击按钮后，立即删除菜单对象；可以通过 异步释放 避免）
多线程常见于：通过弱引用使用资源，但同时资源却被强引用的持有者释放（使用前把弱引用 固定 (pin) 为强引用，持有对象所有权）

自动销毁

资源的释放 位置和时机不可控，往往依赖于垃圾回收系统的实现机制
基于 计数 的自动管理：如果对象之间出现 循环引用，也会导致 资源泄露 问题（可以使用弱引用避免）
基于 跟踪 的自动管理：对于不再使用的对象，如果忘记断开对它的引用，就会出现 不可达引用（例如把资源对象放入 cache 但从不清理），同样导致 资源泄露 问题（需要资源的申请者注意）

#### 资源和对象的映射关系

用于资源管理的对象，往往需要注意它的 拷贝语义：

- 如果资源是不可拷贝的，那么这个对象也是不可拷贝的
- 如果资源可以拷贝，那么对象的拷贝会导致相应资源的拷贝

另外，有时候仅需要使用资源，而不需要拥有资源这里，就涉及到了资源和对象的映射关系。

##### 弱引用关系

有时候，我们仅需要使用一个资源对象，而不需要管理它的生命周期，即 不拥有 (not own) 这个资源。此时表示不拥有资源的引用关系就是弱引用关系。

- 如果被引用对象还有效，读取和修改这个弱引用对象，和直接操作被引用对象一致。

- 如果被引用对象无效，不能读取或修改这个弱引用对象。

##### 强引用关系

###### 一对一关系

同一个资源，在系统中由一个对象来管理。一般这个对象是不可拷贝 (non-copyable) 的（如果不希望资源被拷贝，可以使用这种方法）。

- 互斥所有权 (exclusive ownership)：这个对象创建时申请资源，销毁时释放资源。
- 读取和修改这个可变对象，直接映射到对资源的读取和修改上。

###### 多对一关系

同一个资源，在系统中有多个对象来表示。多个对象共享同一个资源。

共享所有权 (shared ownership)：在第一个对象创建时申请资源，所有对象都销毁时释放资源。
读取任意一个对象，都直接映射到对资源的读取上。

修改其中一个对象：
- 如果使用 可变 (mutable) 对象（引用语义）实现，不仅会修改当前对象表示的资源，还会 自动 把修改应用到其他对象上
- 如果使用 不变 (immutable) 对象（值语义）实现，相当于只操作了资源的一个副本，不影响其他对象；为了保证数据的一致性，往往需要 手动 把修改同步到其他对象上

小结一下


| 实现方式                                                                 | 映射关系                                                                | 可拷贝 | 修改同步 | 失效同步 |
|----------------------------------------------------------------------|---------------------------------------------------------------------|-----|------|------|
| unique_ptr                                                           | 一对一 强引用<span class="Apple-tab-span" style="white-space:pre"></span> | ×   | √    | -    |
| shared_ptr                                                           | 多对一 强引用                                                             | √   | √    | √    |
| 值对象                                                                  | 多对一 强引用<span class="Apple-tab-span" style="white-space:pre"></span> | √   | ×    | ×    |
| weak_ptr<span class="Apple-tab-span" style="white-space:pre"></span> | 弱引用                                                                 | √   | √    | √    |
| 普通指针                                                                 | 弱引用                                                                 | √   | √    | ×    |
