第一章没有实战内容，就简单记录一下复习的基础知识

### 代码环境  
- GCC
- NASM
- 虚拟机（最好是ubuntu16.04，我的虚拟机有点问题，所以用了18.04）
- bochs/qemu

### 读书笔记部分
1. 软件是如何访问硬件的：
硬件在输入输出上大体分为串行和并行，相应的接口也就是串行接口和并行接口。cpu通过串行接口与串行设备数据传输。并行设备的防问类似。
访问外部硬件有两个方式：
   - 将某个外设的内存映射到一定范围的地址空间中，CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让CPU访问外设的内存如同访问主板上的物理内存一样。比如显卡，显卡是显示器的适配器，cpu不直接与显示器交互，他只和显卡通信。显卡上有片内存叫显存，他被映射到主机物理内存上的低端1MB的0xB8000～0xBFFFF。cpu访问这片内存就是访问显存。

   - 外设是通过IO接口与CPU通信的，CPU访问外设，就是访问IO接口，由IO接口将信息传递给另一端的外设。换句话说就是cpu从不知道这些外设的存在，它只知道自己操作的IO接口。访问IO接口，就是访问接口上的寄存器，这些寄存器就是人们常说的端口。
  
2. 内存访问为什么要分段：
   - CPU采用“段基址+段内偏移地址”的方式来访问任意内存，这样使得程序可以重定位。
  
   -  加载用户程序时，只要将整个段的内容复制到新的位置，再将段基址寄存器中的地址改成该地址，程序便可准确无误地运行，因为程序中用的是段内偏移地址，相对于新的段基址，该偏移地址处的内存内容还是一样的。
   -  早期寄存器只有16位，通过将段基址左移4位（乘以16），在和16位段内偏移地址相加，达到20位的效果。

3. 代码中的代码段、数据段和内存的分段机制：
   -  编译器负责挑选出数据具备的属性，从而根据属性将程序片段分类，比如划分出了只读属性的代码段和可写属性的数据段。编译器并没有让段具备某种属性，对于代码段，编译器所做的只是将代码归类到一起而已，也就是将程序中的有关代码的多个section合并成一个大的segment（这就是我们所说的代码段），他并没有为代码段添加额外的信息。
  
   -  操作系统通过设置GDT全局描述符来构建段描述符，在段描述符中指定段的位置、大小及属性（包括S字段和TYPE字段），也就是说操作系统认为代码应该是只读的，所以给用来指向代码段的那个段描述符设置了只读属性，这才是真正给段添加属性的地方
   -  CPU中的段寄存器提前被操作系统赋予相应的选择子，从而确定了指向的段。在执行指令时，会根据该段的属性来判断指令的行为，若没有返回则发出异常。

4. 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别：
   - 物理地址是物理内存的真正的地址，在实模式下，‘段基址+段内偏移’经过段处理器的处理，直接输出了cpu可以直接使用的物理地址。

   - 在保护模式下，‘段基址+段内偏移’被称为线性地址，而且此时的段基址已经成为了选择子，选择子本质上是一个索引，类似于数组下标，通过这个索引便可以在GDT中找到对应的段描述符，在这里可以得到段的起始、大小等信息，也就得到了段基址，如果没有开启分页机制，也就得到了物理地址。
   - 在分页机制下，虚拟地址和线性地址都是一回事，可以理解为线性地址的别名，虚拟地址通过页部件转换成了具体的物理地址。
   - 无论在实模式还是保护模式，段内偏移又叫有效地址，也称为逻辑地址。
    
    ![](img/1.png)

5. BIOS中断、DOS中断和Linux中断：
    - BIOS和DOS都是运行在实模式下的程序，由他们建立的中断调用都是建立在中断向量表中的，他们都是通过软中断指令int号来调用的。
  
   - BIOS的中断调用的主要功能是提供了硬件访问的方法。
   - Linux的系统调用和DOS的中断调用类似，不过Linux是通过int 0x80指令进入一个中断程序，再根据eax的值来调用不同功能的字功能函数。
   - 如果在实模式下执行int指令，会自动去访问中断向量表，如果在保护模式 下执行int指令，则会自动访问中断描述符表。

6. 操作系统如何识别文件系统：
   - 各分区都有超级块，一般位于本分区的第二个扇区，超级块里面记录了此分区的信息，其中就有文件系统的魔数，一种文件系统对应一个魔数，由此可以识别不同的文件系统。
