1.sad师傅：

```
	1.vector容器在增加元素个数的时候，会根据剩余空间考虑是不是要重新分配一块内存来存储。
	而误用的流程就是：在fooA函数中获取容器的一个元素，之后调用fooB函数，在fooB函数中又调用了pushback等增加元素的操作触发了vector的resize,这时候返回fooA函数再使用之前获取的元素就是已经被析构的了。
	这个误用不仅仅会出现在vector中，所有增删操作会让容器重新分配的内存的都会出现。
	经测试asan会显示uaf
	https://paste.ubuntu.com/p/SCtjVMCxxk/
	2.vector的assign操作如果assign的newsize比原有size小，则会将后面多余的元素全部析构。而在遍历容器元素又错误调用了assign之后再使用已经被释放的元素就会造成uaf
	经测试asan会显示uaf
	poc中遍历原大小为10的vector在遍历第五个元素时调用assign将size变为3，此时再使用当前遍历到的第五个元素就会uaf
	https://paste.ubuntu.com/p/hnP9QVk7JK/
	3.为容器erase添加一层新封装的时候如果没有判断删除pos的值会导致删除不存在的元素。
	如下poc，为erase添加新封装remove后没有判断pos的值不能为负数，则用户可以调用remove删除不存在的元素。
	#include <vector>
	using namespace std;
	void remove(int pos, vector<int> vec) {
 	   	vec.erase(vec.begin() + pos);
	}
	int main() {
  	  	vector<int> lll;
  	  	lll.push_back(1);
   	 	remove(-1, lll);
   		return 0;
	}
```
2.pkfxxx师傅:

```
    发现在vector容器的insert和emplace这个两个函数中，在pos位置就地构造元素时，都是直接使用赋值=，如果类型T使用的是默认的赋值构造函数且含有指针类型，
则在参数元素被析构之后，vector容器中还会保留一份副本，会导致UAF。
poc： https://paste.ubuntu.com/p/SHBDQm8G7B/
在linux用asan测试可得到UAF的log
解决办法就是给容器里的类型重载赋值运算符，除此之外，对于有指针类型的类，一定要定义其拷贝构造函数以及对赋值运算符重载，不然很容易出类似的问题。
```
3.f00l师傅：

- vector 

​	pop_back后end迭代器会前向移动一个单位，但是这里它并没有检查移动后的end是否超前于begin，这样如果多次对vector pop，那么end就会超出本vector的范围，那么就会发生越界读写。asan编译后抛出 heap overflow的警告

- list

​	是erase的锅，如果在你疯狂对list进行erase，在它为空的时候，里面会有一个head node，由于list是双向循环链表，这时head node就会指向它自己，此刻在进行erase，就会对head node进行析构，然后释放对应内存，但是list里的erase函数会返回一个指向erase的结点的后继结点的迭代器，这样我们会拿到一个指向已释放内存的指针，会造成uaf。asan编译后会抛use after free的警告。

poc //我把两个写在一起了
```c++
#include <iostream>
#include "stl_alloc.h"
#include "stl_iterator.h"
#include "stl_vector.h"
#include "stl_list.h"
#include "stl_pair.h"
#include "stl_hashtable.h"
#include <vector>
#include<list>
int main() {
    f00l_stl::vector<int>v1(2,10);
    f00l_stl::vector<int>v2(1,10);
    f00l_stl::vector<int>v3(3,10);
    v2.pop_back();
    v2.pop_back();
    v2.pop_back();
    v2.pop_back();
    v2.push_back(0xdeadbeef); //在这里可以把deadbeef写到v1里,越界读写
    //int a1 = v1.at((size_t)&v2/4+1);
    f00l_stl::list<int>l;  
    auto iterator  = l.begin();
    bool a = v1.empty();
    auto m = l.erase(iterator); //在这里会返回一个已经释放的迭代器
    if(a)
        std::cout<<"good"<<std::endl;
    else
        std::cout<<v1[1]<<std::endl;
    //std::cout << "Hello, World!" << std::endl;
    return 0;
}
```
