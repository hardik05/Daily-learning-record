## 用户进程

### TSS
- TSS由用户提供，由CPU自动维护。

- TSS 与其他普通段一样，也有自己的描述符，即 TSS 描述符，用它来描述一个 TSS 的信息，此描述符 需要定义在 GDT 中。寄存器 TR 始终指向当前任务的 TSS。任务切换就是改变 TR 的指向，CPU 自动将当 前寄存器组的值(快照)写入 TR 指向的 TSS，同时 将新任务 TSS 中的各寄存器的值载入 CPU 中对应的 寄存器，从而实现了任务切换。

- TSS 和 LDT 都只能且必须在 GDT 中注册描述符， TR 寄存器中存储的是 TSS 的选择子，LDTR 寄存器中 存储的是 LDT 的选择子，GDTR 寄存器中存储的是 GDT 的起始地址及界限偏移(大小减 1)，全景图如下：

  ![](./img/1.png)
  
### CPU原生支持的任务切换方式
##### 通过“中断+任务门”进行任务切换
###### 中断发生时，通过任务门进行任务切换的过程：
- (1)从该任务门描述符中取出任务的 TSS 选择子。

- (2)用新任务的 TSS 选择子在 GDT 中索引 TSS 描述符。
- (3)判断该 TSS 描述符的 P 位是否为 1，为 1 表示该 TSS 描述符对应的 TSS 已经位于内存中 TSS 描述符指定的位置，可以访问。否则 P 不为 1 表示该 TSS 描述符对应的 TSS 不在内存中，这会导致异常。 
- (4)从寄存器 TR 中获取旧任务的 TSS 位置，保存旧任务(当前任务)的状态到旧 TSS 中。其中，任务状态是指 CPU 中寄存器的值，这仅包括 TSS 结构中列出的寄存器:8 个通用寄存器，6 个段寄存器， 指令指针 eip，栈指针寄存器 esp，页表寄存器 cr3 和标志寄存器 eflags 等。
- (5)把新任务的 TSS 中的值加载到相应的寄存器中。
- (6)使寄存器 TR 指向新任务的 TSS。
- (7)将新任务(当前任务)的 TSS 描述符中的 B 位置 1。 
- (8)将新任务标志寄存器中 eflags 的 NT 位置 1。
- (9)将旧任务的 TSS 选择子写入新任务 TSS 中“上一个任务的 TSS 指针”字段中。 
- (10)开始执行新任务。

在执行新任务之前，旧任务是当前的任务，因此旧任务 TSS 描述符中的 B 位为 1，在调用新任务后 也不会修改，因为它尚未执行完，属于嵌套调用别的任务，并不是单独的任务。

###### 新任务执行完成后的返回工作
当新任务执行完成后，调用 iretd 指令返回到旧任务，此时处理器检查 NT 位，若其值为 1，便进行返 回工作，步骤如下。

- (1)将当前任务(新任务)标志寄存器中 eflags 的 NT 位置 0。
- (2)将当前任务 TSS 描述符中的 B 位置为 0。
- (3)将当前任务的状态信息写入 TR 指向的 TSS。
- (4)获取当前任务 TSS 中“上一个任务的 TSS 指针”字段的值，将其加载到 TR 中，恢复上一个任务的状态。 
- (5)执行上一个任务(当前任务)，从而恢复到旧任务。


##### 通过call、jmp进行任务切换

call 是有去有回的指令，jmp 是一去不回的指令，它们在调用新任务时的区别也在于此。

call 指令以任务嵌套的方式调用新任务，当以 call 指令调用新任务时，我们以操作数为 TSS 选择子为例，比如“call 0x0018:0x1234”，任务切换的步骤如下。

- (1)CPU 忽略偏移量 0x1234，拿选择子 0x0018 在 GDT 中索引到第 3 个描述符。 
- (2)检查描述符中的 P 位，若 P 为 0，表示该描述符对应的段不存在，这将引发异常。同时检查该描述符的 S 与 TYPE 的值，判断其类型，如果是 TSS 描述符，检查该描述符的 B 位，B 位若为 1 将抛出 GP 异常，即表示调用不可重入。
- (3)进行特权级检查，数值上“CPL 和 TSS 选择子中的 RPL”都要小于等于 TSS 描述符的 DPL，否 则抛出 GP 异常。
- (4)特权检查完成后，将当前任务的状态保存到寄存器 TR 指向的 TSS 中。
- (5)加载新任务 TSS 选择子到 TR 寄存器的选择器部分，同时把 TSS 描述符中的起始地址和偏移量 等属性加载到 TR 寄存器中的描述符缓冲器中。
- (6)将新任务 TSS 中的寄存器数据载入到相应的寄存器中，同时进行特权级检查，如果检查未通过， 则抛出 GP 异常。
- (7)CPU 会把新任务的标志寄存器 eflags 中的 NT 位置为 1。
- (8)将旧任务 TSS 选择子写入新任务 TSS 中的字段“上一个任务的 TSS 指针”中，这表示新任务是被 旧任务调用才执行的。
- (9)然后将新任务 TSS 描述符中的 B 位置为 1 以表示任务忙。旧任务 TSS 描述符中的 B 位不变，依 然保持为 1，旧任务的标志寄存器 eflags 中的 NT 位的值保持不变，之前是多少就是多少。
- (10)开始执行新任务，完成任务切换。

jmp 指令以非嵌套的方式调用新任务，新任务和旧任务之间不会形成链式关系。当以 jmp 指令调用新任务时，新任务 TSS 描述符中的 B 位会被 CPU 置为 1 以表示任务忙，旧任务 TSS 描述符中的 B 位会被 CPU 清 0。 

当通过 iretd 指令任务返回时，新任务 eflags 寄存器的 NT 位必须为 1，所以 iretd 仅适用于 call。当调用 iretd 返回到旧任务时，CPU 会将当前任务(新任务)TSS 描述符中 B 位清 0，同时将其 eflags 寄存器的 NT 位清 0。

虽然上面介绍了这么多，但其实我们的现代操作系统如linux，因为效率问题，并没有采用上述方法。

### 实现用户进程

![](./img/2.png)

![](./img/4.png)

![](./img/3.png)